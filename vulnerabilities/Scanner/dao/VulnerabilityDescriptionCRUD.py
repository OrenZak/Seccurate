import sqlite3
from VulnerabilityDescriptionObject import VulnerabilityDescriptionEntity
from datetime import datetime
import ConfigParser


config = ConfigParser.RawConfigParser()
config.read('../common/config.properties')

def createTable(env):
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("PRAGMA foreign_keys=on")
        cursor.execute('CREATE TABLE IF NOT EXISTS Vulnerability_Types(name TEXT PRIMARY KEY,\
                        severity INTEGER not null, description TEXT not null, recommendations TEXT not null)')
        db.commit()

def createVulnerabilityDescription(vuln, env):
    """
    :param payload: payload without id to be inserted to DB
    :return: payload with id after being inserted to DB
    """
    # id = str(datetime.now()).replace('-', '').replace(' ', '').replace(':', '').replace('.', '')
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("PRAGMA foreign_keys=on")
        cursor.execute("""insert into Vulnerability_Types values(?,?,?,?)""", \
                              (vuln.getName(), vuln.getSeverity(), vuln.getDescription(), vuln.getRecommendations()))
        db.commit()
    return vuln

def getVulns(env, size=10, page=0):
    """
    :param size: page size, default 10
    :param page: page number, default 0
    :return:  a list of VulnerabilitiesObjects items from Vulns_Objects DB from page #page of size size
    """
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute(
            """SELECT * from Vulnerability_Types ORDER BY name ASC LIMIT %d OFFSET %d""" % (size, page * size))
        vulns_list = []
        for vuln in cursor.fetchall():
            vulnEntity = VulnerabilityDescriptionEntity(vuln[0], vuln[1], vuln[2], vuln[3])
            vulns_list.append(vulnEntity)
    return vulns_list

def getVulnByName(name, env):
    """
    :param id: VulnerabilitiesObject id
    :return: if id exists - returns VulnerabilitiesObject that is described by that id in the DB
    """
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("""SELECT * from Vulnerability_Types where name = '%s'""" % name)
        item = cursor.fetchone()
        if (item is None):
            raise Exception("No such vulnerability with name %s" % name)
    return VulnerabilityDescriptionEntity(item[0], item[1], item[2], item[3])

def updateVuln(vuln, env):
    """
    :param payload: new payload with existing id
    :return: the new vuln successfully updated in VulnerabilitiesObjects format
    """
    if getVulnByName(vuln.getName(), env) is None:
        raise Exception("no such payload")
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("""update Vulnerability_Types set severity=%d, description='%s', recommendations='%s' \
        where name='%s'""" % (vuln.getSeverity(), vuln.getDescription(), vuln.getRecommendations(), vuln.getName()))
        db.commit()
    return vuln

def deleteVulnByName(name, env):
    if getVulnByName(name, env) is None:
        raise Exception("no such vulnerability")
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("""delete from Vulnerability_Types where name='%s'""" % name)
        db.commit()

def deleteAllDataFromTable(env):
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("""delete from Vulnerability_Types""")
        db.commit()

def dropTable(env):
    with sqlite3.connect(config.get('VulnServiceDB', env)) as db:
        cursor = db.cursor()
        cursor.execute("""DROP TABLE Vulnerability_Types""")
        db.commit()