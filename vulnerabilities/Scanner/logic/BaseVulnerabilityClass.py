from bs4 import BeautifulSoup
from urlparse import urlparse, urljoin
import mechanize
import RXSSCrud
from Methods import GetFormInputFields
import time
import base64
import hashlib
import re
from cookielib import Cookie
from VulnerabilitiesObjects import SimpleVulnerabilityEntity
import VulnerabilitiesCRUD
import SQLICrud
from ConfigParser import RawConfigParser
from CredentialsObject import CredentialsEntity
from cookieExpiration import CookieException
from UnexplainedDifferentHashesException import UnexplainedDifferentHashesException
from DifferentHashesException import DifferentHashesException
from WrongAuthenticationMethodException import WrongAuthenticationMethodException
from copy import deepcopy


class VulnerabilityUtils():

    def __init__(self, tableName, scanType, credentialsEntity=None):
        self.__tableName = tableName
        self.__scanType = scanType
        self.__credentialsEntity = credentialsEntity
        self.authenticationRequired = True
        self.authenticationSupplied = False
        self.authenticationMethod = None
        self.loginPage = None
        self.loginPageHash = None
        self.get_configuration_properties()
        self.formsMap = {}
        self.linksMap = {}
        self.scannedParameters = {}#TODO reset it before start of second order
        self.pendingParameters = {}

        if scanType == 'ALL':
            self.errorBasedPayloads = self.__get_payloads_by_type(payload_type=self.error_based)
            self.errorBasedResponses = self.get_error_based_responses()
            ALLPAYLOADS = 1000
            self.rxssPayloads = self.__getRXSSPayloads(page=0, size=ALLPAYLOADS)
            self.timeBasedPayloads = self.__get_payloads_by_type(payload_type=self.time_based)
        elif scanType == 'SQLI':
            self.errorBasedPayloads = self.__get_payloads_by_type(payload_type=self.error_based)
            self.errorBasedResponses = self.get_error_based_responses()
            self.timeBasedPayloads = self.__get_payloads_by_type(payload_type=self.time_based)
        elif scanType == 'RXSS':
            ALLPAYLOADS = 1000
            self.rxssPayloads = self.__getRXSSPayloads(page=0, size=ALLPAYLOADS)
        self.br = mechanize.Browser()
        self.cookie_jar = mechanize.CookieJar()
        self.init_mechanize()

    def get_configuration_properties(self):
        self.config = RawConfigParser()
        self.config.read('../common/config.properties')

        self.env_type = self.config.get('CurrentEnvironment', 'type')

        # means for authentication
        self.cookie = self.config.get('Authentication', 'Cookie')
        self.baseAuth = self.config.get('Authentication', 'BasicAuthentication')

        self.error_based = self.config.get('SQLITypes', 'error_based')
        self.time_based = self.config.get('SQLITypes', 'time_based')
        self.second_order = self.config.get('SQLITypes', 'second_order')

    def __getRXSSPayloads(self, page=0, size=0):
        return RXSSCrud.getRXSSPayloads(self.env_type, page=page, size=size)

    def __get_payloads_by_type(self, payload_type):
        payloads = []
        i = 0
        page_result = SQLICrud.getPayloadsByType(self.env_type, type=payload_type, page=i)
        while page_result:
            for payload in page_result:
                payloads.append(payload)
            i += 1
            page_result = SQLICrud.getPayloadsByType(self.env_type, type=payload_type, page=i)
        return payloads

    def get_error_based_responses(self):
        error_based_responses = []
        i = 0
        page_result = SQLICrud.getResponses(self.env_type, page=i)
        while page_result:
            for response in page_result:
                error_based_responses.append(response)
            i += 1
            page_result = SQLICrud.getResponses(self.env_type, page=i)
        return error_based_responses

    def getCookieJar(self):
        return self.cookie_jar

    def getErrorBasedPayloads(self):
        return self.errorBasedPayloads

    def getTimeBasedPayloads(self):
        return self.timeBasedPayloads

    def getSecondOrderPayloads(self):
        payloads = list(self.errorBasedPayloads)
        return payloads

    def getRXSSPayloads(self):
        return self.rxssPayloads

    def getErrorBasedResponses(self):
        return self.errorBasedResponses

    def init_mechanize(self):
        self.br.set_cookiejar(self.cookie_jar)

        # Browser options - have to understand what each of them means
        self.br.set_handle_equiv(True)
        self.br.set_handle_gzip(True)
        self.br.set_handle_redirect(True)
        self.br.set_handle_referer(True)
        self.br.set_handle_robots(False)
        self.br.set_handle_refresh(mechanize._http.HTTPRefreshProcessor(),
                                   max_time=1)  # Follows refresh 0 but not hangs on refresh > 1
        # Want debugging messages?
        # br.set_debug_http(True)
        # br.set_debug_redirects(True)
        # br.set_debug_responses(True)

        # User-Agent
        self.br.addheaders = [('User-agent', 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/534.34 \
        (KHTML, like Gecko) Chrome/53.0.2785.113 Safari/534.34')]

    def updateAuthenticationMethod(self):#, sessionEntity, url):
        if not self.authenticationRequired:
            raise UnexplainedDifferentHashesException()
        try:
            self.authenticationMethod = self.__credentialsEntity.getLoginInfo()["authenticationType"]
            if self.authenticationMethod == self.cookie:
                self.loginPage = self.__credentialsEntity.getLoginInfo()["formAction"]
                self.loginPageHash = self.hash_page(str(self.br.open(self.loginPage).read()))
                self.generateNewCookie()
                self.authenticationSupplied = True
            elif self.authenticationMethod == self.baseAuth:
                self.addBaseAuthHeader()
                self.authenticationSupplied = True
        except:
            if self.authenticationMethod is None:
                self.authenticationRequired = False
                return
        if not self.authenticationSupplied:
            raise WrongAuthenticationMethodException()

    def addBaseAuthHeader(self):
        pass
        # self.br.add_password(url=self.__credentialsEntity.getLoginInfo()["formAction"],
        #                      user=self.__credentialsEntity.getLoginInfo()["form"]["username"],
        #                      password=self.__credentialsEntity.getLoginInfo()["form"]["password"])

    def get_injection_points(self, pageEntity):#, sessionEntity):
        if self.authenticationRequired and not self.authenticationSupplied:
            self.updateAuthenticationMethod()
        ######################################################
        # this section should only be applied in sqli algorithm tests
        # try:
        #     self.verifyHash(url=pageEntity.getURL(), expected_hash=pageEntity.getPageHash())
        # except:
        #     self.generateNewCookie()
        ####################################################
        if (not self.formsMap.has_key(pageEntity.getURL())) and (not self.linksMap.has_key(pageEntity.getURL())):
            self.verifyHash(url=pageEntity.getURL())
            forms = {}
            domain = urlparse(pageEntity.getURL()).hostname
            response = str(self.br.open(pageEntity.getURL()).read())
            soup = BeautifulSoup(response, 'html.parser')
            links = self.extract_links(pageEntity.getURL(), domain, soup)
            forms_list = self.extract_forms(soup)
            for form in forms_list:
                (method, inputnames, inputnonames) = GetFormInputFields(pageEntity.getURL(), form)
                str_inputnames = {}
                for k, v in inputnames.iteritems():
                    str_inputnames[k] = unicode(v).encode('utf-8')
                inputnames = str_inputnames
                forms[form] = (method, inputnames, inputnonames)
            self.formsMap[pageEntity.getURL()] = forms
            self.linksMap[pageEntity.getURL()] = links
            return forms, links
        else:
            return self.formsMap[pageEntity.getURL()], self.linksMap[pageEntity.getURL()]

    def extract_links(self, url, domain, soup):
        links_list = []
        if('?' in url):
            links_list.append(url)
        return links_list

    def extract_forms(self, soup):
        return soup.findAll(name='form', action=True)

    def get_url_open_results(self, method, data, url):
        check_r = True
        if method.lower() == "post":
            try:
                # Get Response From the Server
                start = time.time()
                r = self.br.open(url, data.encode('utf-8'))
                end = time.time()
            except Exception as e:
                check_r = False
                event = "<h1>[-]Error:<h1><h2>URL:</h2> " + url + "<br><h2>Data:</h2> " + data.encode(
                    'utf-8') + "<br><h2>Error: </h2>" + str(e) + "<br><br><br><br>"
                print(
                    event)
        else:
            try:
                # Get Response From the Server
                start = time.time()
                request_url = url.split('?')[0] + "?" + data
                r = self.br.open(request_url)
                end = time.time()
            except Exception as e:
                check_r = False
                event = "<h1>[-]Error:<h1><h2>URL:</h2> " + url + "?" + data.encode(
                    'utf-8') + "<br><h2>Error: </h2>" + str(e) + "<br><br><br><br>"
                print(event)  # self.add_event()
        if check_r:
            htmlresponse = str(r.read())
            elapsed_time = end - start
            response_hash = self.hash_page(htmlresponse)
            request = str(method) + "\n" + "url = " + url + "\n" + "fullpayload = " + data
            return [htmlresponse, response_hash, elapsed_time, base64.b64encode(request)]

    def hash_page(self, page):
        self.hashSoup = BeautifulSoup(page, 'html.parser')
        self.remove_changing_attributes_from_soup()
        return hashlib.md5(str(self.hashSoup)).digest()

    def remove_changing_attributes_from_soup(self):
        tags_to_remove = self.hashSoup.find_all(value=re.compile('[-a-zA-Z0-9+_/]{50,}'))
        for tag in tags_to_remove:
            tag.decompose()

    def add_event(self, name=None, url=None, payload=None, requestB64=None, affected_urls=None):
        simpleVulnerability = SimpleVulnerabilityEntity(name=name, url=url, payload=payload, requestB64=requestB64, affected_urls=affected_urls)
        createdVuln = VulnerabilitiesCRUD.createVulnerability(simpleVulnerability, self.__tableName, self.env_type)
        print(createdVuln.getRequestB64())

    def verifyHash(self, url):#, expected_hash):
        """Make sure that current page's hash is not as the login page's hash"""
        if not self.authenticationRequired or self.authenticationMethod != self.cookie or url == self.loginPage:
            return
        if self.getPageHash(url) == self.loginPageHash:
            print("found page with same hash as login page: " + url)
            raise DifferentHashesException(url)

    def getPageHash(self, url):
        r = self.br.open(url)
        response = str(r.read())
        hash = self.hash_page(response)
        return hash

    def compareHashes(self, url, expectedHash):
        if not self.authenticationRequired or self.authenticationMethod != self.cookie:
            return
        hash = self.getPageHash(url=url)
        if hash != expectedHash:
            print ("different hashes in url: " + url)
            raise DifferentHashesException(url=url)

    def generateNewCookie(self):#, credentialsEntity=None):
        print("Entered Generate new cookie Function")
        self.br.open(self.__credentialsEntity.getLoginInfo()["formAction"])
        i = 0
        found = False
        while not found:
            try:
                self.br.select_form(nr=i)
                for control in self.br.form.controls:
                    if control.name in self.__credentialsEntity.getLoginInfo()["form"]:
                        if control.readonly == False:
                            self.br.form[control.name] = self.__credentialsEntity.getLoginInfo()["form"][control.name]
                    else:
                        raise mechanize.FormNotFoundError
                response = self.br.submit()
                found = True
                print ('success')
            except mechanize.FormNotFoundError:
                i += 1
                print ("trying next form")
            except:
                print ("no such form")
                raise Exception("Couldn't find form in login page. Please verify that the supplied login info is correct")

    def get_link_input_names(self, link):
        url = urlparse(link).scheme + "://" + urlparse(link).hostname + urlparse(link).path
        inputnames = {}
        new_injection_points = []
        if len(urlparse(link).query):
            for parameter in urlparse(link).query.split('&'):
                if len(parameter.split('=')) >= 2:
                    inputnames[parameter.split('=')[0]] = parameter.split('=')[1]
                elif len(parameter.split('=')) == 1:
                    inputnames[parameter.split('=')[0]] = ''
            if url in self.pendingParameters.keys():
                return inputnames, self.pendingParameters[url]
            if url in self.scannedParameters.keys():
                for parameter in inputnames.keys():
                    if parameter not in self.scannedParameters[url]:
                        new_injection_points.append({parameter: inputnames[parameter]})
                        self.pendingParameters[url].append({parameter: inputnames[parameter]})
                        #self.scannedParameters[url].append(parameter)
            else:
                #self.scannedParameters[url] = inputnames.keys()
                new_injection_points = inputnames
                self.pendingParameters[url] = inputnames
        return inputnames, new_injection_points

    def free_pending_parameters(self, link):
        url = urlparse(link).scheme + "://" + urlparse(link).hostname + urlparse(link).path
        if url in self.scannedParameters.keys() and len(self.scannedParameters[url]) > 0 and self.pendingParameters.get(url) is not None:
            for parameter in self.pendingParameters[url]:
                self.scannedParameters[url].append(parameter)
        elif url in self.pendingParameters.keys():
            self.scannedParameters[url] = [parameter for parameter in self.pendingParameters[url]]
                #deepcopy(self.pendingParameters[url])
        self.pendingParameters = {}


    def reset_scanned_parameters(self):
        self.scannedParameters = {}

